# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

"""
Native tests in the Hebi-go.
"""

from: unittest :import TestCase

from: hypothesis :import given
from: hypothesis :import strategies :as st
# TODO: why isn't the below version working?
# import: hypothesis.strategies :as st

from: hebi.bootstrap :import function

print: st

print: TestCase

def: greet: name
    print: "Hello," name

class: TestNative: TestCase
    def: .test_mask: self
        self.assertEqual:
            quote:pass:lambda: pass: : foo spam
                builtins..print: "Hi!"
                tests.native_hebi_tests.native_tests..greet: "World!"
                frobnicate: foo 7 24
                reticulate: foo spline
                foo
            pass:  # Example based on cascade macro.
                lambda: pass: thing thing_sym : :* calls
                    !mask:pass:lambda: pass: : :,:thing_sym :,:thing
                        print: "Hi!"  # Builtin symbol.
                        greet: "World!"  # Local symbol.
                        :,@:map:  # Splice
                            lambda: pass:call
                                !mask:pass:  # Nested !mask.
                                    :,:operator..getitem: call 0
                                    :,:thing_sym
                                    :,@:operator..getitem: call slice: 1 None
                            calls
                        :,:thing_sym
                : :*
                quote:pass: spam foo
                    frobnicate: 7 24
                    reticulate: spline
    def: .test_simple_double_unquote: self
        self.assertEqual:
            1
            !let: a :be 1
                !mask:!mask::,::,:a
    def: .test_double_unquote: self
        self.assertEqual:
            quote:pass:
                hebi.bootstrap..entuple: : :? 1  :? 2
                3
            !let: a :be 1
                !mask:pass:
                    !mask:pass: :,::,:a 2
                    3
    def: .test_simple_alternate_double_unquote: self
        self.assertEqual:
            2
            !let: a :be 2
                !mask::,:!mask::,:a
    def: .test_alternate_double_unquote: self
        self.assertEqual:
            quote:pass: 0 pass: 1 2
            !let: a :be 2
                !mask:pass:
                    0
                    :,:!mask:pass: 1 :,:a
    def: .test_simple_double_mask_unquote: self
        self.assertEqual:
            quote:builtins..print
            !let: print :be 3
                !mask:!mask::,:print
    def: .test_double_mask_unquote: self
        self.assertEqual:
            quote:pass:
                0
                hebi.bootstrap..entuple:
                    : :? 1
                    :? 2
                    :? builtins..print
            !let: print :be 3
                !mask:pass:
                    0
                    !mask:pass:
                        1
                        2
                        :,:print
    def: .test_elif: self
        self.assertEqual:
            quote:hebi.bootstrap.._if_:
                ('a'<'b')
                lambda: pass:
                    print: "less"
                lambda: pass:
                    ('a'>'b')
                lambda: pass:
                    print: "more"
                lambda: pass:
                    ('a'=='b')
                lambda: pass:
                    print: "equal"
                : else_
                lambda: pass:
                    print: "nan"
            hebi.bootstrap..if_:
                : :* quote:pass:
                    ('a'<'b')
                    :then:
                        print: "less"
                    :elif: ('a'>'b')
                        print: "more"
                    :elif: ('a'=='b')
                        print: "equal"
                    :else:
                        print: "nan"

class: TestAnd: TestCase
    def: .test_null: self
        self.assertIs:
            True
            and:
    def: .test_one: self x
        :@ given: st.from_type: type
        self.assertIs:
            x
            and: x
    def: .test_two: self x y
        :@ given:
            st.from_type: type
            st.from_type: type
        self.assertIs:
            (x and y)
            and: x y
    def: .test_shortcut: self
        and: 0 (0/0)
        and: 1 0 (0/0)
        and: 0 (0/0) (0/0)
    def: .my_given given
    def: .test_three: self x y z
        :@ .my_given:  # Try to read a decorator from _ns_.
            st.from_type: type
            st.from_type: type
            st.from_type: type
        self.assertIs:
            (x and y and z)
            and: x y z

class: TestOr: TestCase
    def: .test_null: self
        self.assertEqual:
            ()
            or:
    def: .test_one: self x
        :@ given: st.from_type: type
        self.assertIs:
            x
            or: x
    def: .test_two: self x y
        :@ given:
            st.from_type: type
            st.from_type: type
        self.assertIs:
            (x or y)
            or: x y
    def: .test_shortcut: self
        or: 1 (0/0)
        or: 0 1 (0/0)
        or: 1 (0/0) (0/0)
    def: .test_three: self x y z
        :@ given:
            st.from_type: type
            st.from_type: type
            st.from_type: type
        self.assertIs:
            (x or y or z)
            or: x y z

class: TestLet: TestCase
    def: .test_single: self
        self.assertEqual:
            42
            !let: a :be (40 + 2)
                a
    def: .test_2: self
        self.assertEqual:
            24
            !let:
                :,: a b
                :be [20, 4]
                (a + b)
    def: .test_nested: self
        self.assertEqual:
            [-5, -50]
            !let:
                :,: :,: x1 y1
                    :,: x2 y2
                :be [[1, 10],
                       [6, 60]]
                [x1 - x2, y1 - y2]
    def: .test_ignored: self
        self.assertEqual:
            [1, 4, 5]
            !let:
                :,: a _ _ d e
                :be [1, 2, 3, 4, 5]
                [a, d, e]
    def: .test_list: self
        self.assertEqual:
            [1, 2, [3, 4, 5]]
            !let:
                :,: a b :list c
                :be [1, 2, 3, 4, 5]
                [a, b, c]
    def: .test_iter: self
        self.assertEqual:
            ['a', 'c', 'b', 'd', 'e']
            !let:
                :,: a b :iter c
                :be 'abcde'
                [a, next(c), b, *c]
    def: .test_mapping: self
        self.assertEqual:
            ['one', 'bar']
            !let: :=: a 1  b 'foo'
                :be {1: 'one', 'foo': 'bar'}
                [a, b]
    def: .test_nested_mapping: self
        self.assertEqual:
            ['one', 'spam', 'eggs']
            !let:
                :=: a 1
                    :=: b 'foo'
                    2
                    :=: c 'bar'
                    3
                :be {1: 'one',
                       2: {'foo': 'spam'},
                       3: {'bar': 'eggs'}}
                [a, b, c]
    def: .test_too_many: self
        self.assertEqual:
            [1, 2, 3]
            !let:
                :,: a b c
                :be [1, 2, 3, 4, 5]
                [a, b, c]
    def: .test_as: self
        self.assertEqual:
            [[3,7], 3, 7, 'xy', 'x', 'y']
            !let:
                :,: :,: x1 y1 :as point1
                    :,: x2 y2 :as point2
                :be [[3, 7], 'xy']
                [point1, x1, y1, point2, x2, y2]
    def: .test_mapping_as: self
        self.assertEqual:
            ['spam', {1:'spam'}]
            !let: :=: s 1 :as d
                :be {1:'spam'}
                [s, d]
    def: .test_nested_mixed: self
        self.assertEqual:
            ['a', 'b', 'ab']
            !let:
                :=: :,: a b :as s
                    1
                :be {1:'ab'}
                [a, b, s]
        self.assertEqual:
            [[{1:'ab'}], 'ab']
            !let:
                :,: :=: s 1
                    :as d
                :be [{1:'ab'}]
                [d, s]
        self.assertEqual:
            ['a', 'b', [{1:'ab'}], 'ab']
            !let:
                :,:
                    :=: :,: a b :as s
                        1
                    :as d
                :be [{1:'ab'}]
                [a, b, d, s]
        self.assertEqual:
            'spam'
            !let:
                :=: :,: :=: s 2
                    1
                :be {1:[{2:'spam'}]}
                s
    def: .test_strs: self
        self.assertEqual:
            [1, 2, 3]
            !let: :=: :strs: a b c
                :be {'a':1, 'b':2, 'c':3}
                [a, b, c]
    def: .test_default: self
        self.assertEqual:
            ['A','b','C','d']
            !let: :=: a 1  b 2  c 3  d 4  :default: a 'A'  b 'X'  c 'C'
                :be {2:'b', 4:'d'}
                [a,b,c,d]
    def: .test_default_strs: self
        self.assertEqual:
            ['ab', 22, 33]
            !let:
                :=: :strs: a b c
                    :default: a ('a'+'b')
                :be {'b':22,'c':33}
                [a, b, c]

class: TestLoop: TestCase
    def: .test_loop: self
        self.assertEqual:
            'cba'
            !loop: recur: xs 'abc'  ys ''
                if: xs
                    :then: (recur(xs[:-1], ys + xs[-1]))
                    :else: ys
    def: .test_try_iter: self
        !let: xs :be []
            !loop: recur: it iter:'abc'
                try: .append: xs .upper:next:it
                    :except: StopIteration
                    :else: recur:it
            self.assertEqual:
                ['A', 'B', 'C']
                xs
    def: .test_for: self
        !let: xs :be []
            for: c :in 'abc'
                .append: xs .upper:c
            self.assertEqual:
                ['A', 'B', 'C']
                xs
    def: .test_for_bind: self
        !let: xs :be []
            for: :,: c i
                :in zip: 'abc' [1,2,3]
                xs.append:(c*i)
            self.assertEqual:
                ['a','bb','ccc']
                xs
    def: .test_break: self
        !let: cs :be iter:'abcdefg'
            self.assertEqual:
                'c'
                for: c :in cs
                    if: (c=='c')
                        :then: break: c
            self.assertEqual:
                ['d', 'e', 'f', 'g']
                list:cs
        self.assertEqual:
            None
            for: c :in 'abc'
                if: (c=='c')
                    :then: break:
    def: .test_labeled_break: self
        !let: ijs :be []
            self.assertEqual:
                1
                for: :top i :in [0,1,2,3]
                    for: j :in [2,1]
                        ijs.append: [i, j]
                        if: (i==j) :then: break: :top i
            self.assertEqual:
                [[0, 2],
                 [0, 1],
                 [1, 2],
                 [1, 1]]
                ijs
    def: .test_continue: self
        !let: ijs :be []
            self.assertEqual:
                ()
                for: i :in [1,2,3]
                    for: j :in [1,2,3]
                        if: (i==j) :then: continue:
                        ijs.append: [i, j]
            self.assertEqual:
                [[1, 2],
                 [1, 3],
                 [2, 1],
                 [2, 3],
                 [3, 1],
                 [3, 2]]
                ijs
    def: .test_labeled_continue: self
        !let: ijs :be []
            self.assertEqual:
                ()
                for: :top i :in [1,2,3]
                    for: j :in [1,2,3]
                        if: (i==j) :then: continue: :top
                        ijs.append: [i, j]
            self.assertEqual:
                [[2, 1],
                 [3, 1],
                 [3, 2]]
                ijs
    def: .test_for_else: self
        self.assertEqual:
            'c'
            for: c :in 'abcdefg'
                if: (c=='c') :then: break: c
                :else: 'z'
        self.assertEqual:
            'z'
            for: c :in 'abcdefg'
                if: (c=='C') :then: break: c
                :else: 'z'

class: TestDef: TestCase
    def: .test_def_ns: self
        """ How to emulate local reassignment. """
        !let: o :be types..SimpleNamespace:
            def: o.foo 2
            def: o.foo (o.foo * 3)
            self.assertEqual:
                6
                o.foo
    def: .test_def_anaphoric_ns: self
        !let: _ns_ :be types..SimpleNamespace:
            def: .foo 2
            def: .foo (_ns_.foo * 3)
            self.assertEqual:
                6
                _ns_.foo

class: TestBegin: TestCase
    "Test Begin Docstring."
    def: .test_begin: self
        !let: xs :be []
            self.assertEqual:
                3
                !begin:
                    xs.append: 1
                    xs.append: 2
                    3
            self.assertEqual: xs [1, 2]
    def: .test_begin_empty: self
        self.assertEqual:
            ()
            !begin:
    def: .test_begin0: self
        !let: xs :be []
            self.assertEqual:
                0
                !begin0:
                    0
                    xs.append: 1
                    xs.append: 2
            self.assertEqual: xs [1, 2]

class: TestClass: TestCase
    # test __module__ set
    # test __qualname__ set
    # test __doc__ set if present
    # test __doc__ not set if not present
    # test class in class with anaphoric _ns_
    # test class inside def
    # test decorator order
    # test anaphoric _ns_ decorator
    # test anaphoric _ns_ decorator factory
    # test metaclass with kwargs
    def: .test_super: self
        !let: o :be types..SimpleNamespace:
            class: o.Spam:
                def: .__init__: self
                    super:
                    None
            o.Spam:

# TODO: test try

#def: __package__ "tests.native_hebi_tests"

import: unittest

if: (__name__ == "__main__")
    :then:
        # print: __package__
        # from: . :import recompile
        .main: unittest
        # recompile:
